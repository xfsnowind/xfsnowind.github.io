[{"body":"","link":"https://xfsnowind.github.io/blogs/","section":"blogs","tags":null,"title":"Blogs"},{"body":"","link":"https://xfsnowind.github.io/tags/javascript/","section":"tags","tags":null,"title":"Javascript"},{"body":"This article is a summary when I learned the React Hooks course in GeekTime. Even though we all use React Hooks in the frontend development, I cannot say I understand the internal core and logic of it. So this is a good time to re-learn it through this course. According to my experience, it's definitely better to write down the idea and thoughts down -- The palest ink is better than the best memory. Therefore have this article. And I would follow the course's original structure to organize the article.\nBasic chapter Reason to Hooks The nature of React is mapping the Model to View and the Model is the Component's props and state. So when Model's data change, React does not care how they change, it only focuses on the difference. And this is what we called declarative and this is implemented by React's diff function.\nSo UI presentation is more like execution of function. Model is parameter, View is function and the result would be the Dom's change. React just confirms to execute the process of changing in an optimized way.\nBefore we use class to create React Component, but actually it's not suit for React Component:\nWe rarely use inheritance in React Component; React is state driven and does not need generated instance's methods; But function also has its own limitation:\nFunction cannot provide internal state, it must be a pure function; Function cannot provide the entire lifecycle; The comes React Hooks.\nReact Hooks \u0026quot;binds\u0026quot; or \u0026quot;hooks\u0026quot; the target to some may changed data or event source. And when the hooked data or event change, the target would be executed again to generate the new result.\nThe hooked source can be not only data, also the result of another Hooks execution.\nHooks is created with the background of using High order Component, and it solves the problems of wrapper hell and code hard to understanding.\nHooks basic usage useState -- The principle of using useState is unnecessary to save the value which can be gotton from calculating. useEffect -- Should only be used to execute the code which would not effect the current result, not effect the rendered UI. And also be careful for the deps, it use reference to check if values have been changed, so take care of object and array. NB: useEffect is called after rendering useCallback -- The purpose is when need to pass function as parameter to UI, avoid triggering React render component. useMemo -- can be treated as combination of useEffect and useState. When deps change, execute useEffect to calculate the value and set the value through useState useRef Share data between multiple rendering Save the ref of a Dom node useContext -- define the global state useEffect can be equivalent to componentDidMount, componentDidUpdate and componentWillUnmount, but not exactly. The difference is\nuseEffect's callback functions are triggered only when deps change. While componentDidUpdate would be called every rendering useEffect's callback function return a function, which is used to clean, would be triggered before deps change or component unmount. If we need a constructor feature, we can use the code below:\n1function useSingleton(callback) { 2 // 用一个 called ref 标记 callback 是否执行过 3 const called = useRef(false); 4 // 如果已经执行过，则直接返回 5 if (called.current) return; 6 // 第一次调用时直接执行 7 callBack(); 8 // 设置标记为已执行过 9 called.current = true; 10} NB: Hooks can implement most functionalities of lifecycle, but not for getSnapshotBeforeUpdate, componentDidCatch, getDerivedStateFromError. These can only be implemented by class.\nPractice Data consistence The principle of using useState is keep state minimum.\nIf the data can be calculated or generated by the existing ones, then we should not store them in state.\nWhen we define the new state, ask yourself: is this state necessary? Can it be obtained by calculation? Is it just a middleware state?\nHandle rendering scenario Since Hooks cannot be handled in conditions and loops, we should move the condition into useEffect og create a wrapper for the component and return null in some conditions.\nAlthough we have Hooks now, it can only be used for logical reuse. If it comes to the UI behaviour, Hooks cannot play a role then. Therefore, we can use Render props mode.\nRender props Mode is just another presentation of High-ordering Component, which means Component takes functions as paramter or return functions. And then we can use the passed function to render, kind of like dependency injection. For example:\n1function CounterRenderProps({ children }) { 2 const [count, setCount] = useState(0); 3 const increment = useCallback(() =\u0026gt; { 4 setCount(count + 1); 5 }, [count]); 6 const decrement = useCallback(() =\u0026gt; { 7 setCount(count - 1); 8 }, [count]); 9 10 return children({ count, increment, decrement }); 11} 12 13function CounterRenderPropsExample() { 14 return ( 15 \u0026lt;CounterRenderProps\u0026gt; 16 {({ count, increment, decrement }) =\u0026gt; { 17 ... 18 }} 19 \u0026lt;/CounterRenderProps\u0026gt; 20 ); 21} So we leave children to render to make code reusable. Here, it does not have to be children, it can be any functions.\nSelf defined event When we bind an event to a node, because of Virtual Dom, React would bind the event to the app's root node. Before version 17, it's on document, after version 17, it's the react's root node. The reason to do this:\nWhen Virtual Dom renders, the node may have not been mounted to the page, so it cannot bind; It can block all the details from low level and avoid browser's compatible problem So React's event actually is the callback function.\nOrganize project structure via business To reduce the complexibility, we can organize the project based on service characteristic, so each feature can be independent and easy to manage and maintain.\nTo meet the requirement of low coupling, we can define some high level, abstract components to be reused among components.\nForm React is state driven, while Form is event driven。 The difference of React's onChange and html's onchange is onChange would be called whenever user inputs, while onchange is only triggered when the input loses focus.\nControlled vs uncontrolled For uncontrolled component, it would not pass the value to component, can only get the value actively, like useRef. The advantage is it would not toggle the rendering, although we cannot see the change of value as well.\nWhile for controlled component, it accepts value as props and add a callback function to update it.\nForm elements If we use Controlled component to build form, it would have three core parts:\nthe type of form element bind the value handle the onChange event So Hooks' contribution to form is, we can save the form's values to Hooks and provide the function to handle them through useState. For example:\n1import { useState, useCallback } from \u0026#34;react\u0026#34;; 2 3const useForm = (initialValues = {}) =\u0026gt; { 4 // define the state for the whole form：values 5 const [values, setValues] = useState(initialValues); 6 7 // provide a method to set the value of some field 8 const setFieldValue = useCallback((name, value) =\u0026gt; { 9 setValues((values) =\u0026gt; ({ 10 ...values, 11 [name]: value, 12 })); 13 }, []); 14 15 // return the values and the method 16 return { values, setFieldValue }; 17}; ","link":"https://xfsnowind.github.io/blogs/geektime/react-hooks/","section":"blogs","tags":["Javascript","React Hooks","Learning Notes"],"title":"Learning Note - React Hooks"},{"body":"","link":"https://xfsnowind.github.io/tags/learning-notes/","section":"tags","tags":null,"title":"Learning Notes"},{"body":"","link":"https://xfsnowind.github.io/tags/react-hooks/","section":"tags","tags":null,"title":"React Hooks"},{"body":"","link":"https://xfsnowind.github.io/tags/","section":"tags","tags":null,"title":"Tags"},{"body":"","link":"https://xfsnowind.github.io/","section":"","tags":null,"title":"xfsnowind"},{"body":"","link":"https://xfsnowind.github.io/tags/promise/","section":"tags","tags":null,"title":"Promise"},{"body":"Promise is a general concept to handle the asynchronize development in javascript. It's not hard to use, but when it comes with some other concepts, like react's hook, its internal chain etc. It always takes me some time to think through it. Especially when check the code of some open-source libraries, find the way they use Promise is quite fancy and also hard to understand, which reminders me that I am still stay on the level of using, far away from deep understanding.\nInspired by this blog, I think it's a good idea to write promise by myself. It's not only because it's not that hard and complex, it can also help me in the future work when I meet it again. Thesedays, function programing is quite popular in js development, but object-orient coding is still used in lots of scenarioes. So I would like to try to implement it with both function and class, even though javascript's prototype is almost equal to class concept, which was introduced in ES2015. It can also train these basic skills again. I would deploy them in my github and write blogs to record it.\nThanks to promise/A+, we get the requirement analysis, clear logic and library to test the solution.\nSteps According to the Promise/A+'s requirements, I think it would be four steps:\nBasic then function -- 1.1, 1.2 Fulfill Promise and then parameters -- from 2.1 to 2.2.5 Return a Promise in then -- 2.2.6, 2.2.7 resolve function -- 2.3 Basic thenable According to the Terminology, the first two are promise and thenable. The former should take a function (an executor) as parameter which would take two functions (resolve and reject) as parameters as well. Check Higher-order functions. These resolve and reject would be used in the executor and defined in the then's parameters. Let's simply implement this thenable first.\n1function Promise(executor) { 2 let self = this; 3 self.executor = executor; 4} 5 6Promise.prototype.then = function (onFulfilled, onRejected) { 7 let self = this; 8 self.executor(onFulfilled, onRejected); 9}; As we see, we just delay the execution of executor from Promise to then and the fulfill and reject functions are used in executor while defined or passed in then.\nWe can use below code to test it. NB: do not use arrow function in definition, because arrow function does not own this. If we use this inside of it, it would refer to the outer function. Check here.\n1const a = new Promise((resolve) =\u0026gt; setTimeout(() =\u0026gt; resolve(\u0026#34;result\u0026#34;), 100)); 2 3a.then((data) =\u0026gt; console.log(\u0026#34;Data\u0026#34;, data)); 4// console.log -\u0026gt; Data: result But obviously here, we only have one executor and the parameters are not validated. Besides executor runs in the then, not in the Promise. Currently, the code is simple, but it would cause problems. We will mention this below, let's go further.\nFulfill Promise and then parameters Validate then parameters 2.2.1 Both onFulfilled and onRejected are optional arguments:\n2.2.1.1 If onFulfilled is not a function, it must be ignored.\n2.2.1.2 If onRejected is not a function, it must be ignored.\nonFulfilled and onRejected should be validated:\n1let fulfillFunc = isFunction(onFulfilled) ? onFulfilled : (value) =\u0026gt; value; 2let rejectFunc = isFunction(onRejected) 3 ? onRejected 4 : (e) =\u0026gt; { 5 throw e; 6 }; Update state After validating the parameters, we can implement the point 2.2.2 and 2.2.3. Translate here:\nIf onFulfilled/onRejected is a function,\nit must be called after promise is fulfilled/rejected, with promise's value/reason as its first argument;\nit must not be called before promise is fulfilled/rejected;\nit must not be called more than once;\nSo we need to set the state and pass the value or reason to related functions. To do this, I wrap the validated functions and update internal states inside of them:\n1// 2.2.2.1 onFulfilled must be called after promise is fulfilled, with promise’s value as its first argument. 2function resolve(value) { 3 if (self.state === STATE.PENDING) { 4 // 2.2.2.2 it must not be called before promise is fulfilled. 5 self.state = STATE.FULFILLED; 6 self.value = value; 7 fulfillFunc(value); 8 } 9} 10 11// 2.2.3.1 onRejected must be called after promise is rejected, with promise’s reason as its first argument. 12function reject(err) { 13 if (self.state === STATE.PENDING) { 14 // 2.2.3.2 it must not be called before promise is rejected. 15 self.state = STATE.REJECTED; 16 self.value = err; 17 rejectFunc(err); 18 } 19} Asynchronized execution According to the first point 2.2.4 refering NOTE 3.1, we should execute the fulfill and reject functions asynchronously, which is the main reason for people using it. In javascript, we can utilize setTimeout.\n1setTimeout(() =\u0026gt; fulfillFunc(value), 0); Return Promise in then Before we continue implementing the rest requirement, we need to reorganize the codes first. We need to move the executor from then to the constructor of Promise.\nWhy? One main reason is we will execute the executor multiple times if it's in then, since one promise can have multiple thens. This is definitely unacceptable because we only need to execute executor once.\nSo til now, the Promise function looks like this:\n1function Promise(executor) { 2 let self = this; 3 4 // set the state as pending, 2.1.1 5 self.state = STATE.PENDING; 6 7 // 2.2.2.1 onFulfilled must be called after promise is fulfilled, with promise’s value as its first argument. 8 function resolve(value) { 9 if (self.state === STATE.PENDING) { 10 // 2.2.2.2 it must not be called before promise is fulfilled. 11 self.state = STATE.FULFILLED; 12 self.value = value; 13 setTimeout(() =\u0026gt; resolveFunc(value), 0); 14 } 15 } 16 17 // 2.2.3.1 onRejected must be called after promise is rejected, with promise’s reason as its first argument. 18 function reject(err) { 19 if (self.state === STATE.PENDING) { 20 // 2.2.3.2 it must not be called before promise is rejected. 21 self.state = STATE.REJECTED; 22 self.value = err; 23 setTimeout(() =\u0026gt; rejectFunc(err), 0); 24 } 25 } 26 27 try { 28 // executor is function whose parameters is resolve and reject functions, 29 // which would be called inside of executor. 30 if (isFunction(executor)) executor(resolve, reject); 31 } catch (err) { 32 reject(err); 33 } 34} And you may notice we use the function resolveFunc and rejectFunc, but we haven't define them. They would work together with the requirement of multiple calling of then.\nCall then mutiple times 2.2.6 2.2.6 then may be called multiple times on the same promise.\nSo all the respective fulfill/reject functions should be called in the order of original calls. Obviously, we can apply a queue here. Create a callback queue, add then's onFulfilled and onRejected parameters to it and handle it when fulfilled/rejected. And this is how we handle the above resolveFunc and rejectFunc.\n1function resolve(value) { 2 ... 3 // 2.2.6.1 4 setTimeout( 5 () =\u0026gt; self.callback.forEach(({ resolveFunc }) =\u0026gt; resolveFunc(value)), 6 0 7 ); 8} 9 10function reject(err) { 11 ... 12 // 2.2.6.2 13 setTimeout( 14 () =\u0026gt; self.callback.forEach(({ rejectFunc }) =\u0026gt; rejectFunc(err)), 15 0 16 ); 17} When Promise is fulfilled/rejected, we would execute all the related functions in the queue. And obviously, we have to push the callback functions to the queue in then when the state is still pending.\n1Promise.prototype.then = function (onFulfilled, onRejected) { 2 let self = this; 3 4 // 2.2.1 Both onFulfilled and onRejected are optional arguments, if any is not function, must ignore it 5 let fulfillFunc = isFunction(onFulfilled) ? onFulfilled : (value) =\u0026gt; value; 6 let rejectFunc = isFunction(onRejected) 7 ? onRejected 8 : (e) =\u0026gt; { 9 throw e; 10 }; 11 12 switch (self.state) { 13 // if the state is fulfilled or rejected, just execute the related function and pass the result to the resolvePromise 14 case STATE.FULFILLED: 15 case STATE.REJECTED: 16 return setTimeout(() =\u0026gt; { 17 try { 18 let func = self.state == STATE.FULFILLED ? fulfillFunc : rejectFunc; 19 func(self.value); 20 } catch (e) { 21 rejectFunc(e); 22 } 23 }, 0); 24 case STATE.PENDING: 25 // if it\u0026#39;s still pending, push the resolve/reject to callback queue. All the callback functions would be executed once state are changed 26 return self.callback.push({ 27 resolveFunc: () =\u0026gt; { 28 try { 29 fulfillFunc(self.value); 30 } catch (e) { 31 rejectFunc(e); 32 } 33 }, 34 rejectFunc: () =\u0026gt; { 35 try { 36 rejectFunc(self.value); 37 } catch (e) { 38 rejectFunc(e); 39 } 40 }, 41 }); 42 } 43}; Return Promise 2.2.7 Here comes the difficult part, then should return a Promise which would support the chaining feature.\nthen must return a promise [3.3].\npromise2 = promise1.then(onFulfilled, onRejected);\nAfter reading other implementations, here comes a question. Would this promise2 have its own executor? Yes or no would have different implementations.\nLet's first implement the simple one - Yes. It would have its own resolve/reject functions in executor. I would implement the optimized one -- No, with an empty promise, in another blog.\nAnother thing we need to think of is what if the value returned by promise2 is a promise. This is what the 2.3 Promise Resolution Procedure would do. Let's preserve this to later chapter and assume the value returned by promise2 is NOT another promise Then the logic of this promise2's executor should be:\nIf the state is fulfilled, the value returned by the onFulfilled function should be passed to resolve2 function in promise2's executor If the state is rejected, the value returned by the onRejected function should be passed to reject2 function in promise2's executor If the state is still pending, pass the resolveFunc and rejectFunc which would call resolve2 and reject2, to callback queue Any exception throwed by onFulfilled or onRejected should be handled by reject2 And we can extract the process of handling self.value as a function to reuse code.\n1function handleResult(resolve2, reject2) { 2 return () =\u0026gt; { 3 try { 4 // 2.2.7.1, 2.2.7.2 5 let func = self.state == STATE.FULFILLED ? fulfillFunc : rejectFunc; 6 let func2 = self.state == STATE.FULFILLED ? resolve2 : reject2; 7 func2(func(self.value)); 8 } catch (e) { 9 reject2(e); 10 } 11 }; 12} Til now, we have implement the features\nReturn Promise in then to support chaining Multiple then of one Promise The codes should be like this:\n1const STATE = { 2 PENDING: Symbol.for(\u0026#34;pending\u0026#34;), 3 FULFILLED: Symbol.for(\u0026#34;fulfilled\u0026#34;), 4 REJECTED: Symbol.for(\u0026#34;rejected\u0026#34;), 5}; 6 7const isFunction = (func) =\u0026gt; func \u0026amp;\u0026amp; typeof func === \u0026#34;function\u0026#34;; 8const isObject = (arg) =\u0026gt; arg \u0026amp;\u0026amp; typeof arg === \u0026#34;object\u0026#34;; 9 10function Promise(executor) { 11 let self = this; 12 13 // set the state as pending, 2.1.1 14 self.state = STATE.PENDING; 15 16 self.callback = []; 17 18 // 2.2.2.1 onFulfilled must be called after promise is fulfilled, with promise’s value as its first argument. 19 function resolve(value) { 20 if (self.state === STATE.PENDING) { 21 // 2.2.2.2 it must not be called before promise is fulfilled. 22 self.state = STATE.FULFILLED; 23 self.value = value; 24 // 2.2.6.1 25 setTimeout( 26 () =\u0026gt; self.callback.forEach(({ resolveFunc }) =\u0026gt; resolveFunc(value)), 27 0 28 ); 29 } 30 } 31 32 // 2.2.3.1 onRejected must be called after promise is rejected, with promise’s reason as its first argument. 33 function reject(err) { 34 if (self.state === STATE.PENDING) { 35 // 2.2.3.2 it must not be called before promise is rejected. 36 self.state = STATE.REJECTED; 37 self.value = err; 38 // 2.2.6.2 39 setTimeout( 40 () =\u0026gt; self.callback.forEach(({ rejectFunc }) =\u0026gt; rejectFunc(err)), 41 0 42 ); 43 } 44 } 45 46 try { 47 // executor is function whose parameters is resolve and reject functions, 48 // which would be called inside of executor. 49 if (isFunction(executor)) executor(resolve, reject); 50 } catch (err) { 51 reject(err); 52 } 53} 54 55Promise.prototype.then = function (onFulfilled, onRejected) { 56 let self = this; 57 58 // 2.2.1 Both onFulfilled and onRejected are optional arguments, if any is not function, must ignore it 59 let fulfillFunc = isFunction(onFulfilled) ? onFulfilled : (value) =\u0026gt; value; 60 let rejectFunc = isFunction(onRejected) 61 ? onRejected 62 : (e) =\u0026gt; { 63 throw e; 64 }; 65 66 function handleResult(resolve2, reject2) { 67 return () =\u0026gt; { 68 try { 69 // 2.2.7.1, 2.2.7.2 70 let func = self.state == STATE.FULFILLED ? fulfillFunc : rejectFunc; 71 let func2 = self.state == STATE.FULFILLED ? resolve2 : reject2; 72 func2(func(self.value)); 73 } catch (e) { 74 reject2(e); 75 } 76 }; 77 } 78 79 return new Promise((resolve2, reject2) =\u0026gt; { 80 switch (self.state) { 81 // if the state is fulfilled or rejected, just execute the related function and pass the result to the resolvePromise 82 case STATE.FULFILLED: 83 return setTimeout(handleResult(resolve2, reject2), 0); 84 case STATE.REJECTED: 85 return setTimeout(handleResult(resolve2, reject2), 0); 86 case STATE.PENDING: 87 // if it\u0026#39;s still pending, push the resolve/reject to callback queue. All the callback functions would be executed once state are changed 88 return self.callback.push({ 89 resolveFunc: handleResult(resolve2, reject2), 90 rejectFunc: handleResult(resolve2, reject2), 91 }); 92 } 93 }); 94}; Let's simply test it:\n1const p1 = new Promise((resolve, reject) =\u0026gt; { 2 setTimeout(() =\u0026gt; resolve(\u0026#34;resolved first one\u0026#34;), 3000); 3}); 4 5p1.then((res) =\u0026gt; { 6 console.log(\u0026#34;then1: \u0026#34;, res); 7 return res; 8}).then((res) =\u0026gt; { 9 setTimeout(() =\u0026gt; console.log(\u0026#34;then2: \u0026#34;, res), 1000); 10}); 11 12p1.then((res) =\u0026gt; { 13 console.log(\u0026#34;another then: \u0026#34;, res); 14}); 15 16// then1: resolved first one 17// another then: resolved first one 18// then2: resolved first one Promise Resolution Procedure 2.3 Here comes the last step, implement the Promise Resolution Procedure. According to the description of requirement:\nThis treatment of thenables allows promise implementations to interoperate, as long as they expose a Promises/A+-compliant then method. It also allows Promises/A+ implementations to “assimilate” nonconformant implementations with reasonable then methods.\nAnd before we begin to implement, let's think of why we have to have this resolvePromise, since it calls itself inside recursively. Comparing the text explanation, let me present one test case from Promise/A+. The case is generated by two loops, I just pick one here.\nAdapter In the test case, an adapter is utilized and explained in the Promise/A+ as well, check adapter;\n1Promise.defer = Promise.deferred = function () { 2 let dfd = {}; 3 dfd.promise = new Promise((resolve, reject) =\u0026gt; { 4 dfd.resolve = resolve; 5 dfd.reject = reject; 6 }); 7 return dfd; 8}; 9 10adapter.resolved = function (value) { 11 var d = adapter.deferred(); 12 d.resolve(value); 13 return d.promise; 14}; Definitely, we have seen this resolved many times, but what it does exactly? Through its code, we can understand it\nCreate a promise with a very simple executor which normally executes the logic of asynchronous codes Resolve the promise with the value immediately by updating state and saving the value before we have this resolve method Return this created promise So for the code resolved(value), actually it just preserves the value and waiting the resolve method from its then. When its then is called, the value would be passed to resolve method immediately.\nTest case The test case's description is\ny is an already-fulfilled promise for a synchronously-fulfilled custom thenable, then calls resolvePromise synchronously\nAnd I can simplify the test code, removing all the wrapped test functions:\n1const result = { result }; 2 3var promise = resolved({ dummy }).then(function onBasePromiseFulfilled() { 4 return { 5 then: function (resolvePromise) { 6 resolvePromise( 7 resolved({ 8 then: function (onFulfilled) { 9 onFulfilled(result); 10 }, 11 }) 12 ); 13 }, 14 }; 15}); 16 17promise.then(function onPromiseFulfilled(value) { 18 assert.strictEqual(value, result); 19 done(); 20}); Yes, HHHHHHHHeadache!!!!\nDefinitely there are a lot of promises wrapped like matryoshka doll, and so hard to dig into it. Yes, I know, but we can analysis the codes step by step, at leas we can simply count how many promises are here:\nresolved({ dummy }) uses resolved. As explained above, it returns a resolved promise and waits for the resolve method from its then. Let's call this promise as promise-TEMP; promise-TEMP called then which passes the function onBasePromiseFulfilled as resolve. AND it returns our first promise -- promise onBasePromiseFulfilled return a thenable object as value of promise. Let's call it x; x, which we can simply treat it as a Promise as well -- promise2, has the then function which would call its parameter resolvePromise further. The called value would be the value of promise2. Let's call it y; The value passed to resolvePromise is another resolved promise -- promise3, which is fulfilled and has no resolve method. But its value is another thenable object -- or promise4; Finally we reach the bottom level, the resolve method onFulfilled of promise4's then calls the result; So let's count how many promises and values we have here (ignore the promise-TEMP):\npromise -- the only one having name in our test codes its value x -\u0026gt; promise2 promise2 -- first thenable object its value y -\u0026gt; promise3 promise3 -- a resolved promise its value -\u0026gt; promise4 promise4 -- second thenable object its value -\u0026gt; result, an object So we can see the value of promise is a promise -- promise2 which wraps another two promises -- promise3 and promise4. And the assert sits inside of the resolve onPromiseFulfilled method of the first promise, it would expect the value returned by onPromiseFulfilled to be the same with result, which is the value of promise4.\nWe can conclude some points here:\nThe thenable object can be treated as a promise, which means they can be handled as the same codes. (This is not a principle, we can discuss this in another blog) If the value of a promise is a thenable object, the promise's resolve/reject methods would be passed to the value until the final value is not a promise and handled by the original resolve/reject methods. Implementation OK, it's enough to learn from the test case, even though it's what I learned after I passed all the test cases. Let's go back to the requirements and implement it.\nSince thenable object can be treated as promise, we would ignore the requirement of 2.3.2:\n2.3.2 If x is a promise, adopt its state [3.4]:\n2.3.2.1 If x is pending, promise must remain pending until x is fulfilled or rejected.\n2.3.2.2 If/when x is fulfilled, fulfill promise with the same value.\n2.3.2.3 If/when x is rejected, reject promise with the same reason.\nThis point can be merged with 2.3.3. Others would not be hard, just follow the steps:\n1function resolvePromise(promise, x, resolve2, reject2) { 2 if (promise == x) { 3 return reject2( 4 new TypeError(\u0026#34;Resolved result should not be the same promise!\u0026#34;) 5 ); 6 } else if (x \u0026amp;\u0026amp; (isFunction(x) || isObject(x))) { 7 let called = false; // 2.3.3.3.3 8 9 try { 10 let then = x.then; 11 12 if (isFunction(then)) { 13 then.call( // 2.3.3.3 14 x, 15 function (y) { 16 if (called) return; // 2.3.3.3.3 17 called = true; 18 return resolvePromise(promise, y, resolve2, reject2); // 2.3.3.3.1 19 }, 20 function (r) { 21 if (called) return; 22 called = true; 23 return reject2(r); // 2.3.3.3.2 24 } 25 ); 26 } else { 27 resolve2(x); // 2.3.3.4 28 } 29 } catch (err) { 30 if (called) return; // 2.3.3.3.4.1 31 called = true; 32 reject2(err); // 2.3.3.3.4.2 33 } 34 } else { 35 resolve2(x); // 2.3.4 36 } 37} Test Now we have implemented all the mandatory codes, we can run the test the codes with npm lib promises-aplus-tests.\n1npm i -g promises-aplus-tests 2promises-aplus-tests promise1.js // promise1.js is the file name The full code can be checked here. There are different versions with different techniques, you can choose anyone.\nSummary This solution is not perfect and it just simply follows the rules of Promise/A+ without any better architecture and design. There are a lot of good solutions which restructures the codes with their own idea and logic. I would rewrite the promise with other techniques later.\nBesides, this version just completes the basic part. Promise also has resolve, catch, finally, etc. I will implement them as well and write another article about them.\nThanks to this article, which inspires me to make decision to implement the Promise and Zhi Sun's article, which reminders me of taking steps to implement the hard part.\n","link":"https://xfsnowind.github.io/blogs/promise/","section":"blogs","tags":["Javascript","Promise"],"title":"Promise"},{"body":"The techniques and some project I plan to learn or finish:\ngRPC vs REST -- get some knowledge of gRPC Esbuild, vite, svelte -- understand the difference of vite and esbuild, apply esbuild for develop and webpack for production webpack hotload ES6 ES7 -- get overview of ES6 and ES7 Command kitty -- get familiar with kitty material design -- get to know how to use material design Flutter vs React Native -- get some overview of mobile development React-hook form website with react, redux -- use react-hook-form to generate a full form again and deploy Hugo personal github page -- xfsnowind React long lists -- how to render the long list if it's over 1 million Go through test framework of js, jest, react-testing-library -- review the test library of js Blog for learning geektime -- learning some topics throught geektime http headers -- go through the http headers to get an overview Regular express forward -- deep learn the regex forward again Terraform -- get knowledge of it Promise -- write promise self with different js tech until not forget it any more Kubernetes ","link":"https://xfsnowind.github.io/blogs/learning-plan/","section":"blogs","tags":null,"title":"Learning Plan"},{"body":"I am a full stack developer and I would record some technical ideas and articles here. And it may also post some flash time in life.\n","link":"https://xfsnowind.github.io/about/","section":"","tags":null,"title":"About"},{"body":"","link":"https://xfsnowind.github.io/categories/","section":"categories","tags":null,"title":"Categories"},{"body":"","link":"https://xfsnowind.github.io/series/","section":"series","tags":null,"title":"Series"}]