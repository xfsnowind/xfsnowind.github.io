[{"body":"","link":"https://xfsnowind.github.io/zh-cn/tags/blogs/","section":"tags","tags":null,"title":"Blogs"},{"body":"","link":"https://xfsnowind.github.io/zh-cn/blogs/","section":"blogs","tags":null,"title":"Blogs"},{"body":"","link":"https://xfsnowind.github.io/zh-cn/tags/react/","section":"tags","tags":null,"title":"React"},{"body":"","link":"https://xfsnowind.github.io/zh-cn/tags/react-query/","section":"tags","tags":null,"title":"React Query"},{"body":"","link":"https://xfsnowind.github.io/zh-cn/tags/","section":"tags","tags":null,"title":"Tags"},{"body":"","link":"https://xfsnowind.github.io/zh-cn/tags/translation/","section":"tags","tags":null,"title":"Translation"},{"body":"","link":"https://xfsnowind.github.io/zh-cn/tags/typescript/","section":"tags","tags":null,"title":"Typescript"},{"body":"","link":"https://xfsnowind.github.io/zh-cn/","section":"","tags":null,"title":"xfsnowind"},{"body":" 本文翻译自 TkDodo 的 Using WebSockets with React Query\n如何使用WebSockets与React Query处理实时数据是最近最常被问到的问题之一，因此我想尝试一下，并报告我的发现。这就是本文的内容 :)\n什么是WebSockets 简而言之，WebSockets允许从服务器推送消息或\u0026quot;实时数据\u0026quot;到客户端（浏览器）。通常情况下，使用HTTP时，客户端向服务器发出请求，希望获取一些数据，服务器响应该数据或错误，然后连接关闭。\n由于客户端是打开连接并发起请求的一方，这就没有机会让服务器在有更新可用时向客户端推送数据。\n这就是WebSockets的作用。\n就像其他HTTP请求一样，浏览器发起连接，但表示希望将连接升级为WebSocket。如果服务器接受了这个请求，它们将切换协议。这个连接不会终止，而是保持打开状态，直到任一方决定关闭它。现在，我们拥有了一个完全功能的双向连接，双方都可以传输数据。\n这主要的优点是服务器现在可以向客户端推送选择性的更新。如果多个用户查看相同的数据，并且其中一个用户进行了更新。通常情况下，其他客户端在主动刷新之前不会看到该更新。而使用WebSockets可以实时推送这些更新。\nReact Query 集成 由于React Query主要是一个客户端异步状态管理库，所以我不会讨论如何在服务器上设置WebSockets。老实说，我从没做过，而且还取决于你在后端使用的技术。\nReact Query没有专门为WebSockets构建的内置功能。这并不意味着不支持WebSockets，或者它们与库的兼容性不好。只是当涉及到数据获取时，React Query在使用方式上非常不偏不倚：它只需要一个已解决或拒绝的Promise即可工作 - 其余的由你决定。\n逐步进行 一般的思路是按照通常的方式设置查询，就像你不使用WebSockets一样。大多数情况下，你将拥有用于查询和更改实体的常规HTTP端点。\n1const usePosts = () =\u0026gt; 2 useQuery({ queryKey: [\u0026#39;posts\u0026#39;, \u0026#39;list\u0026#39;], queryFn: fetchPosts }) 3 4const usePost = (id) =\u0026gt; 5 useQuery({ 6 queryKey: [\u0026#39;posts\u0026#39;, \u0026#39;detail\u0026#39;, id], 7 queryFn: () =\u0026gt; fetchPost(id), 8 }) 此外，你可以设置一个全局的useEffect来连接到WebSocket终端。具体如何操作完全取决于你使用的技术。我看到过有人从Hasura订阅实时数据。有一篇很棒的文章介绍了如何连接到Firebase。在我的示例中，我将简单地使用浏览器原生的WebSocket API：\n1const useReactQuerySubscription = () =\u0026gt; { 2 React.useEffect(() =\u0026gt; { 3 const websocket = new WebSocket(\u0026#39;wss://echo.websocket.org/\u0026#39;) 4 websocket.onopen = () =\u0026gt; { 5 console.log(\u0026#39;connected\u0026#39;) 6 } 7 8 return () =\u0026gt; { 9 websocket.close() 10 } 11 }, []) 12} 处理数据 在设置连接之后，当WebSocket上有数据传入时，我们很可能会有一些回调函数会被调用。再次强调，数据的具体内容完全取决于你的设置方式。受到 Tanner Linsley发布的这条信息的启发，我喜欢从后端发送事件而不是完整的数据对象：\n1const useReactQuerySubscription = () =\u0026gt; { 2 const queryClient = useQueryClient() 3 React.useEffect(() =\u0026gt; { 4 const websocket = new WebSocket(\u0026#39;wss://echo.websocket.org/\u0026#39;) 5 websocket.onopen = () =\u0026gt; { 6 console.log(\u0026#39;connected\u0026#39;) 7 } 8 websocket.onmessage = (event) =\u0026gt; { 9 const data = JSON.parse(event.data) 10 const queryKey = [...data.entity, data.id].filter(Boolean) 11 queryClient.invalidateQueries({ queryKey }) 12 } 13 14 return () =\u0026gt; { 15 websocket.close() 16 } 17 }, [queryClient]) 18} 这就是在接收到事件时更新列表和详细视图的全部内容了。\n{ \u0026quot;entity\u0026quot;: [\u0026quot;posts\u0026quot;, \u0026quot;list\u0026quot;] } 将使post list无效 { \u0026quot;entity\u0026quot;: [\u0026quot;posts\u0026quot;, \u0026quot;detail\u0026quot;], id: 5 } 将使单个post无效 { \u0026quot;entity\u0026quot;: [\u0026quot;posts\u0026quot;] } 将使所有和post有关的无效 查询无效与WebSockets非常匹配。这种方法避免了过度推送的问题，因为如果我们接收到的事件与我们当前不感兴趣的实体相关，什么都不会发生。例如，如果我们当前在个人资料页面，而我们接收到了post的更新，invalidateQueries将确保下次我们进入post页面时会重新获取数据。然而，它不会立即重新获取数据，因为我们没有活动的观察者。如果我们再也不去那个页面，推送的更新将是完全不必要的。\n更新部分数据 当然，如果你有大型数据集，但是频繁接收小的更新，你可能仍然希望通过WebSocket推送部分数据。\npost的标题发生了变化？只需推送标题。点赞数发生变化？也推送下来。\n对于这些部分更新，你可以使用queryClient.setQueryData直接更新查询缓存，而不是使其无效。\n如果你的同一数据有多个查询键，例如，如果你的查询键中包含多个过滤条件，或者如果你想使用同一条消息更新列表视图和详细视图，那么这将变得有些麻烦。queryClient.setQueriesData是该库的一个相对较新的功能，它允许你处理这种情况：\n1const useReactQuerySubscription = () =\u0026gt; { 2 const queryClient = useQueryClient() 3 React.useEffect(() =\u0026gt; { 4 const websocket = new WebSocket(\u0026#39;wss://echo.websocket.org/\u0026#39;) 5 websocket.onopen = () =\u0026gt; { 6 console.log(\u0026#39;connected\u0026#39;) 7 } 8 websocket.onmessage = (event) =\u0026gt; { 9 const data = JSON.parse(event.data) 10 queryClient.setQueriesData(data.entity, (oldData) =\u0026gt; { 11 const update = (entity) =\u0026gt; 12 entity.id === data.id ? { ...entity, ...data.payload } : entity 13 return Array.isArray(oldData) ? oldData.map(update) : update(oldData) 14 }) 15 } 16 17 return () =\u0026gt; { 18 websocket.close() 19 } 20 }, [queryClient]) 21} 对于我个人而言，这种方法有点太动态了，无法处理添加或删除，并且 TypeScript 对此也不太友好，所以我个人更倾向于使用查询无效。\n尽管如此，在这里有一个CodeSandbox示例，我在其中处理了无效和部分更新两种类型的事件。（注意：在示例中，自定义hook有点复杂，因为我使用相同的WebSocket模拟了服务器的往返。如果你有一个真实的服务器，就不必担心这个问题）。\n增加过期时间 React Query的默认过期时间是0。这意味着每个查询都会立即被视为过期，也就是说，当新的订阅者挂载或用户重新聚焦窗口时，它会重新获取数据。这是为了保持数据的最新状态。\n这个目标与WebSockets的目标有很多重叠，因为WebSockets实时更新数据。如果服务器刚刚通过专用消息告诉我手动使其 无效，为什么我还需要重新获取数据呢？\n因此，如果你无论如何都通过WebSockets更新所有数据，请考虑设置一个较长的staleTime。在我的示例中，我只是使用了Infinity。这意味着数据将通过useQuery进行初始获取，然后始终从缓存中获取。重新获取只会通过显式的查询无效来发生。\n在创建QueryClient时，通过设置全局查询默认值可以最好地实现这一点。\n1const queryClient = new QueryClient({ 2 defaultOptions: { 3 queries: { 4 staleTime: Infinity, 5 }, 6 }, 7}) 今天就到这里。如果你有任何问题，请随时在 Twitter 上与我联系，或者在下面留言。\n","link":"https://xfsnowind.github.io/zh-cn/blogs/react-query/using-web-sockets-with-react-query/","section":"blogs","tags":["React","React Query","Typescript","Translation","Blogs"],"title":"使用React Query和Web Sockets"},{"body":" 本文翻译自 TkDodo 的 Testing React Query\n谈到测试，经常会和React Query一起出现一些问题，所以我将在这里尝试回答其中的一些问题。我认为其中一个原因是测试“智能”组件（也称为容器组件）并不是一件容易的事情。随着hooks的兴起，这种分离已经大部分过时。现在倾向于直接在需要它们的地方使用hooks，而不是进行主要是随意地分离并向下传递props。\n我认为这通常是一个非常好的改进，有助于集中放置和代码可读性，但现在更多组件会去消耗props之外的依赖项。\n它们可能是useContext。它们可能是useSelector。或者它们可能是useQuery。\n这些组件在技术上不再是纯净的，因为在不同的环境中调用它们会导致不同的结果。在测试它们时，你需要仔细设置这些周围的环境以使其正常工作。\n模拟网络请求 由于React Query是一个异步的服务器状态管理库，你的组件很可能会向后端发送请求。在测试时，这个后端无法用以提供真实数据，即使可用，你可能也不希望使测试依赖于它。\n已经有海量的文章介绍如何使用jest模拟数据。如果你有api客户端，可以模拟它。你可以直接模拟fetch或axios。我非常认同Kent C. Dodds在他的文章《Stop mocking fetch》中所写的内容：\n使用@ApiMocking的mock service worker\n在模拟API方面，它可以成为你的唯一真实来源：\n适用于测试的Node环境 支持REST和GraphQL 具有storybook插件，因此你可以为使用useQuery的组件编写story 在浏览器中用于开发目的，你仍然可以在浏览器开发工具中看到请求的发送情况 与Cypress一起使用，类似于fixtures 通过处理我们的网络层，我们可以开始讨论一些需要关注的React Query特定事项：\nQueryClientProvider 每当你使用React Query时，你需要一个QueryClientProvider，并给它一个queryClient——这是一个保存QueryCache的容器。而Cache会保存你的请求的数据。\n我更喜欢为每个测试提供独立的QueryClientProvider，并为每个测试创建一个新的QueryClient。这样，测试之间完全隔离。另一种方法可能是在每个测试之后清除缓存，但我喜欢尽量将测试之间的共享状态保持最小化。否则，如果你同时运行测试，可能会出现意外和不稳定的结果。\n对于自定义的Hooks 如果你正在测试自定义hooks，我非常确定你正在使用react-hooks-testing-library。这是最简单的测试hooks的方法。我们可以通过这个库将我们的钩子包装在一个包装器中，该包装器是一个React组件，在渲染时用于包装测试组件。我认为这是创建QueryClient的理想位置，因为它将在每个测试中都执行一次：\n1const createWrapper = () =\u0026gt; { 2 // ✅ creates a new QueryClient for each test 3 const queryClient = new QueryClient() 4 return ({ children }) =\u0026gt; ( 5 \u0026lt;QueryClientProvider client={queryClient}\u0026gt;{children}\u0026lt;/QueryClientProvider\u0026gt; 6 ) 7} 8 9test(\u0026#34;my first test\u0026#34;, async () =\u0026gt; { 10 const { result } = renderHook(() =\u0026gt; useCustomHook(), { 11 wrapper: createWrapper() 12 }) 13}) 对于组件 如果你想测试一个使用useQuery hooks的组件，你还需要将该组件包在QueryClientProvider中。使用react-testing-library里的一个小包装器包住render似乎是一个不错的选择。看看React Query在他们的测试中是如何内部处理的。\n关闭重试 这是使用React Query进行测试时最常见的问题之一：该库默认使用指数轮询进行三次重试，这意味着如果你想测试一个错误的查询，测试很可能会超时。最简单的方法是通过QueryClientProvider关闭重试。让我们扩展上面的示例：\n1const createWrapper = () =\u0026gt; { 2 const queryClient = new QueryClient({ 3 defaultOptions: { 4 queries: { 5 // ✅ turns retries off 6 retry: false, 7 }, 8 }, 9 }) 10 11 return ({ children }) =\u0026gt; ( 12 \u0026lt;QueryClientProvider client={queryClient}\u0026gt;{children}\u0026lt;/QueryClientProvider\u0026gt; 13 ) 14} 15 16test(\u0026#34;my first test\u0026#34;, async () =\u0026gt; { 17 const { result } = renderHook(() =\u0026gt; useCustomHook(), { 18 wrapper: createWrapper() 19 }) 20} 这会将组件树中所有查询默认设置为“无重试”。重要的是，这仅在你的实际的useQuery没有显性设置重试时才起作用。如果你有一个要求5次重试的查询，它仍会优先使用这5次重试设置，因为默认值仅作为备用。\nsetQueryDefaults The best advice I can give you for this problem is: Don't set these options on useQuery directly. Try to use and override the defaults as much as possible, and if you really need to change something for specific queries, use queryClient.setQueryDefaults.\nSo for example, instead of setting retry on useQuery:\n我可以给你的最佳建议是：不要在useQuery上直接设置这些选项。尽可能使用和覆盖默认值，如果你确实需要针对特定查询更改某些东西，请使用queryClient.setQueryDefaults。\n例如，避免在useQuery上设置重试参数:\n1const queryClient = new QueryClient() 2 3function App() { 4 return ( 5 \u0026lt;QueryClientProvider client={queryClient}\u0026gt; 6 \u0026lt;Example /\u0026gt; 7 \u0026lt;/QueryClientProvider\u0026gt; 8 ) 9} 10 11function Example() { 12 // 🚨 you cannot override this setting for tests! 13 const queryInfo = useQuery({ 14 queryKey: [\u0026#39;todos\u0026#39;], 15 queryFn: fetchTodos, 16 retry: 5, 17 }) 18} 改成这样：\n1const queryClient = new QueryClient({ 2 defaultOptions: { 3 queries: { 4 retry: 2, 5 }, 6 }, 7}) 8 9// ✅ only todos will retry 5 times 10queryClient.setQueryDefaults([\u0026#39;todos\u0026#39;], { retry: 5 }) 11 12function App() { 13 return ( 14 \u0026lt;QueryClientProvider client={queryClient}\u0026gt; 15 \u0026lt;Example /\u0026gt; 16 \u0026lt;/QueryClientProvider\u0026gt; 17 ) 18} 这样，所有的查询都会尝试两次，只有todos会重试五次，而且我也还有选项来在测试中把所有的查询都关掉🙌。\nReactQueryConfigProvider 当然，这仅适用于已知的查询键。有时，你确实需要在组件树的某个子集上设置一些配置。在v2中，React Query提供了ReactQueryConfigProvider来满足这个特定的用例。你可以在v3中使用几行代码实现相同的效果：\n1const ReactQueryConfigProvider = ({ children, defaultOptions }) =\u0026gt; { 2 const client = useQueryClient() 3 const [newClient] = React.useState( 4 () =\u0026gt; 5 new QueryClient({ 6 queryCache: client.getQueryCache(), 7 muationCache: client.getMutationCache(), 8 defaultOptions, 9 }) 10 ) 11 12 return ( 13 \u0026lt;QueryClientProvider client={newClient}\u0026gt;{children}\u0026lt;/QueryClientProvider\u0026gt; 14 ) 15} 你也可以在这个codesandbox的示例里看到。\n始终等待查询的完成 Since React Query is async by nature, when running the hook, you won't immediately get a result. It usually will be in loading state and without data to check. The async utilities from react-hooks-testing-library offer a lot of ways to solve this problem. For the simplest case, we can just wait until the query has transitioned to success state:\n由于React Query的本质是异步的，当运行hooks时，你并不会立即获得结果。它通常处于加载状态并且没有数据可供检查。react-hooks-testing-library的异步工具提供了许多解决此问题的方法。对于最简单的情况，我们可以等待查询过渡到成功状态：\n1const createWrapper = () =\u0026gt; { 2 const queryClient = new QueryClient({ 3 defaultOptions: { 4 queries: { 5 retry: false, 6 }, 7 }, 8 }) 9 return ({ children }) =\u0026gt; ( 10 \u0026lt;QueryClientProvider client={queryClient}\u0026gt;{children}\u0026lt;/QueryClientProvider\u0026gt; 11 ) 12} 13 14test(\u0026#34;my first test\u0026#34;, async () =\u0026gt; { 15 const { result, waitFor } = renderHook(() =\u0026gt; useCustomHook(), { 16 wrapper: createWrapper() 17 }) 18 19 // ✅ wait until the query has transitioned to success state 20 await waitFor(() =\u0026gt; result.current.isSuccess) 21 22 expect(result.current.data).toBeDefined() 23} 更新：\n@testing-library/react v13.1.0也有一个新的渲染hook。然而，它并不返回自己的waitFor，因此你需要从@testing-library/react导入。其API有些不同，它不允许返回布尔值，而是期望返回一个Promise。这意味着我们必须稍微调整我们的代码：\n1import { waitFor, renderHook } from \u0026#39;@testing-library/react\u0026#39; 2 3test(\u0026#34;my first test\u0026#34;, async () =\u0026gt; { 4 const { result } = renderHook(() =\u0026gt; useCustomHook(), { 5 wrapper: createWrapper() 6 }) 7 8 // ✅ return a Promise via expect to waitFor 9 await waitFor(() =\u0026gt; expect(result.current.isSuccess).toBe(true)) 10 11 expect(result.current.data).toBeDefined() 12} 静默错误控制台 默认情况下，React Query将错误打印到控制台。我认为这在测试过程中相当令人困扰，因为即使所有测试都是绿色的，你也会在控制台上看到🔴。React Query允许通过设置日志记录器来覆盖默认行为，这通常是我所做的：\n1import { setLogger } from \u0026#39;react-query\u0026#39; 2 3setLogger({ 4 log: console.log, 5 warn: console.warn, 6 // ✅ no more errors on the console 7 error: () =\u0026gt; {}, 8}) 更新：\nsetLogger已经从v4中移除了。取而代之的，你可以把你自定义的logger作为参数传递给你所创建的QueryClient:\n1const queryClient = new QueryClient({ 2 logger: { 3 log: console.log, 4 warn: console.warn, 5 // ✅ no more errors on the console 6 error: () =\u0026gt; {}, 7 } 8}) 此外，在生产模式下不再记录错误，以避免混淆。\n将它们整合在一起 我创建了一个快速的存储库，将所有这些内容完美地结合在一起：mock-service-worker、react-testing-library和上述的包装器。它包含四个测试 - 用于自定义hook和组件的失败和成功示例。请在此处查看：https://github.com/TkDodo/testing-react-query\n","link":"https://xfsnowind.github.io/zh-cn/blogs/react-query/testing-react-query/","section":"blogs","tags":["React","React Query","Typescript","Translation","Blogs"],"title":"测试React Query"},{"body":"","link":"https://xfsnowind.github.io/zh-cn/tags/javascript/","section":"tags","tags":null,"title":"Javascript"},{"body":"","link":"https://xfsnowind.github.io/zh-cn/tags/learning-notes/","section":"tags","tags":null,"title":"Learning Notes"},{"body":"Basic chapter Reason to Hooks React的本质就是从Model到View的映射。这里的Model就是Component的props和state。\n当Model的数据变化时，React不管它是怎么变化的，只关心它变化之后和之前的区别。这也就是所谓的声明式declarative，而这通过React的diff函数来实现。\n所以UI的展现更像是一个函数的执行。Model是输入参数，View是函数，执行结果就是Dom的改变。而React只要保证通过最优的办法执行变化的过程就行了。\nClass作为React Component不合适的两点:\nReact Component之间很少使用继承. React是由state驱动的，并不需要调用外部生成的class的instance的method。 Function作为React Component的局限:\nFunction无法提供内部状态，必须是纯函数 Function也无法提供完整的lifecycle 所以React的中的Hooks就是把target钩到某个可能会变化的data source或者event source中，当被钩到的data或者event变化的时候，这个target会被重新执行，产生新的结果。\nHooks中被钩的对象不仅仅可以是数据，也可以是另一个Hook执行的结果，这样可以带来逻辑的复用。\nHooks是在High order Component的使用背景下被创造出来的，所以Hook解决了HOC留下的wrapper hell和code难以理解的问题\nHooks basic usage useState -- 使用useState保存的值的原则是，不要使用需要计算得到的值 useEffect -- 应该用来执行并不影响当前结果的代码，是不影响当前渲染出来的UI的 Deps使用reference来比较值是否有变化，所以数组和object要小心 NB: useEffect是在render执行之后调用的 useCallback -- 这个hook的使用目的是，在需要把函数作为值来传递到UI的时候，为了避免多余的render，而保证在某些条件传递的函数本身是不变的 useMemo -- useMemo其实可以理解为useEffect和useState的结合，即在deps变化的时候来执行useEffect的函数来计算值的变化，同时将值通过useState来赋予state useRef 在多次渲染之间共享数据 存某个 DOM 节点的引用 useContext -- 定义全局状态 useEffect基本上等价于componentDidMount, componentDidUpdate 和componentWillUnmount。但是并不完全等价。区别在于： useEffect的callback函数只有在deps变化的时候才会被调用，而componentDidUpdate则一定会被调用 useEffect里callback函数的返回函数(用来做清理工作)，是在依赖项变化或者组件销毁前被调用\n如果需要有一个constructor的功能，可以使用以下代码：\n1// 创建一个自定义 Hook 用于执行一次性代码 2function useSingleton(callback) { 3 // 用一个 called ref 标记 callback 是否执行过 4 const called = useRef(false); 5 // 如果已经执行过，则直接返回 6 if (called.current) return; 7 // 第一次调用时直接执行 8 callBack(); 9 // 设置标记为已执行过 10 called.current = true; 11} Hook可以实现大部分的lifecycle的功能，但是对于 getSnapshotBeforeUpdate, componentDidCatch, getDerivedStateFromError，这些周期还是只能使用class来实现\nPractice Data consistence 在保证 State 完整性的同时，也要保证它的最小化。 某些数据如果能从已有的 State 中计算得到，那么我们就应该始终在用的时候去计算，而不要把计算的结果存到某个 State 中。\n避免中间状态，确保唯一数据源 在任何时候想要定义新状态的时候，都要问自己一下：这个状态有必要吗？是否能通过计算得到？是否只是一个中间状态？\nRender props模式 通过把render函数传递给某个组件，让这个render函数来决定渲染的效果，从而实现组件的复用\nSelf defined event Synthetic Event 当我们绑定一个时间到节点上的时候，因为virtual dom的存在，react会把时间绑定到APP根节点上，React 17之前是在document上，17以后是在react的根节点上 一是因为virtual dom在render的时候，可能节点还没有render到页面上，所以无法绑定 二是可以屏蔽底层细节，避免浏览器兼容性问题\n所以react component自定义的事件本质上是回调函数\nOrganize project structure via business 为了降低项目的复杂度，通过业务特征和逻辑来组织项目结构，这样可以让各个feature能相对独立，便于管理和维护\n为了实现松耦合，可以针对dynamic的部分单独设计组件，并传递动态的参数以达到动态内容的修改不影响其他部分\nForm React是状态驱动，Form是事件驱动 React的onChange函数会在用户任何输入的时候都调用函数，但是html的原生onchange函数则只会在输入框失去focus的时候触发\nControlled vs uncontrolled 对于uncontrolled component，并不会传递value给component，而是通过获取这个component的值来得到其状态，例如useRef。好处在于，其值的变化并不会触发render。坏处则是无法检测值的变化\n而对于controlled component，则接受value as props，同时一个callback函数来update这个值\nForm elements 使用Controlled component来维护表单主要核心三个部分：\n字段的名称 绑定value 处理onChange事件 所以Hook对于Form的贡献在于，可以把Form里面的value都放到hook里面，并且通过useState来提供处理的函数。例如：\n1import { useState, useCallback } from \u0026#34;react\u0026#34;; 2 3const useForm = (initialValues = {}) =\u0026gt; { 4 // 设置整个 form 的状态：values 5 const [values, setValues] = useState(initialValues); 6 7 // 提供一个方法用于设置 form 上的某个字段的值 8 const setFieldValue = useCallback((name, value) =\u0026gt; { 9 setValues((values) =\u0026gt; ({ 10 ...values, 11 [name]: value, 12 })); 13 }, []); 14 15 // 返回整个 form 的值以及设置值的方法 16 return { values, setFieldValue }; 17}; ","link":"https://xfsnowind.github.io/zh-cn/blogs/geektime/react-hooks/","section":"blogs","tags":["Javascript","React Hooks","Learning Notes"],"title":"Learning Notes - React Hooks"},{"body":"","link":"https://xfsnowind.github.io/zh-cn/tags/react-hooks/","section":"tags","tags":null,"title":"React Hooks"},{"body":"","link":"https://xfsnowind.github.io/zh-cn/categories/","section":"categories","tags":null,"title":"Categories"},{"body":"","link":"https://xfsnowind.github.io/zh-cn/series/","section":"series","tags":null,"title":"Series"}]