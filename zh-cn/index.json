[{"body":"","link":"https://xfsnowind.github.io/zh-cn/tags/blogs/","section":"tags","tags":null,"title":"Blogs"},{"body":"","link":"https://xfsnowind.github.io/zh-cn/blogs/","section":"blogs","tags":null,"title":"Blogs"},{"body":"","link":"https://xfsnowind.github.io/zh-cn/tags/react-query/","section":"tags","tags":null,"title":"React Query"},{"body":"","link":"https://xfsnowind.github.io/zh-cn/tags/","section":"tags","tags":null,"title":"Tags"},{"body":"","link":"https://xfsnowind.github.io/zh-cn/tags/translation/","section":"tags","tags":null,"title":"Translation"},{"body":"","link":"https://xfsnowind.github.io/zh-cn/","section":"","tags":null,"title":"xfsnowind"},{"body":" 本文翻译自 TkDodo 的 Testing React Query\n谈到测试，经常会和React Query一起出现一些问题，所以我将在这里尝试回答其中的一些问题。我认为其中一个原因是测试“智能”组件（也称为容器组件）并不是一件容易的事情。随着hooks的兴起，这种分离已经大部分过时。现在倾向于直接在需要它们的地方使用hooks，而不是进行主要是随意地分离并向下传递props。\n我认为这通常是一个非常好的改进，有助于集中放置和代码可读性，但现在更多组件会去消耗props之外的依赖项。\n它们可能是useContext。它们可能是useSelector。或者它们可能是useQuery。\n这些组件在技术上不再是纯净的，因为在不同的环境中调用它们会导致不同的结果。在测试它们时，你需要仔细设置这些周围的环境以使其正常工作。\n模拟网络请求 由于React Query是一个异步的服务器状态管理库，你的组件很可能会向后端发送请求。在测试时，这个后端无法用以提供真实数据，即使可用，你可能也不希望使测试依赖于它。\n已经有海量的文章介绍如何使用jest模拟数据。如果你有api客户端，可以模拟它。你可以直接模拟fetch或axios。我非常认同Kent C. Dodds在他的文章《Stop mocking fetch》中所写的内容：\n使用@ApiMocking的mock service worker\n在模拟API方面，它可以成为你的唯一真实来源：\n适用于测试的Node环境 支持REST和GraphQL 具有storybook插件，因此你可以为使用useQuery的组件编写story 在浏览器中用于开发目的，你仍然可以在浏览器开发工具中看到请求的发送情况 与Cypress一起使用，类似于fixtures 通过处理我们的网络层，我们可以开始讨论一些需要关注的React Query特定事项：\nQueryClientProvider 每当你使用React Query时，你需要一个QueryClientProvider，并给它一个queryClient——这是一个保存QueryCache的容器。而Cache会保存你的请求的数据。\n我更喜欢为每个测试提供独立的QueryClientProvider，并为每个测试创建一个新的QueryClient。这样，测试之间完全隔离。另一种方法可能是在每个测试之后清除缓存，但我喜欢尽量将测试之间的共享状态保持最小化。否则，如果你同时运行测试，可能会出现意外和不稳定的结果。\n对于自定义的Hooks 如果你正在测试自定义hooks，我非常确定你正在使用react-hooks-testing-library。这是最简单的测试hooks的方法。我们可以通过这个库将我们的钩子包装在一个包装器中，该包装器是一个React组件，在渲染时用于包装测试组件。我认为这是创建QueryClient的理想位置，因为它将在每个测试中都执行一次：\n1const createWrapper = () =\u0026gt; { 2 // ✅ creates a new QueryClient for each test 3 const queryClient = new QueryClient() 4 return ({ children }) =\u0026gt; ( 5 \u0026lt;QueryClientProvider client={queryClient}\u0026gt;{children}\u0026lt;/QueryClientProvider\u0026gt; 6 ) 7} 8 9test(\u0026#34;my first test\u0026#34;, async () =\u0026gt; { 10 const { result } = renderHook(() =\u0026gt; useCustomHook(), { 11 wrapper: createWrapper() 12 }) 13}) 对于组件 如果你想测试一个使用useQuery hooks的组件，你还需要将该组件包在QueryClientProvider中。使用react-testing-library里的一个小包装器包住render似乎是一个不错的选择。看看React Query在他们的测试中是如何内部处理的。\n关闭重试 这是使用React Query进行测试时最常见的问题之一：该库默认使用指数轮询进行三次重试，这意味着如果你想测试一个错误的查询，测试很可能会超时。最简单的方法是通过QueryClientProvider关闭重试。让我们扩展上面的示例：\n1const createWrapper = () =\u0026gt; { 2 const queryClient = new QueryClient({ 3 defaultOptions: { 4 queries: { 5 // ✅ turns retries off 6 retry: false, 7 }, 8 }, 9 }) 10 11 return ({ children }) =\u0026gt; ( 12 \u0026lt;QueryClientProvider client={queryClient}\u0026gt;{children}\u0026lt;/QueryClientProvider\u0026gt; 13 ) 14} 15 16test(\u0026#34;my first test\u0026#34;, async () =\u0026gt; { 17 const { result } = renderHook(() =\u0026gt; useCustomHook(), { 18 wrapper: createWrapper() 19 }) 20} 这会将组件树中所有查询默认设置为“无重试”。重要的是，这仅在你的实际的useQuery没有显性设置重试时才起作用。如果你有一个要求5次重试的查询，它仍会优先使用这5次重试设置，因为默认值仅作为备用。\nsetQueryDefaults The best advice I can give you for this problem is: Don't set these options on useQuery directly. Try to use and override the defaults as much as possible, and if you really need to change something for specific queries, use queryClient.setQueryDefaults.\nSo for example, instead of setting retry on useQuery:\n我可以给你的最佳建议是：不要在useQuery上直接设置这些选项。尽可能使用和覆盖默认值，如果你确实需要针对特定查询更改某些东西，请使用queryClient.setQueryDefaults。\n例如，避免在useQuery上设置重试参数:\n1const queryClient = new QueryClient() 2 3function App() { 4 return ( 5 \u0026lt;QueryClientProvider client={queryClient}\u0026gt; 6 \u0026lt;Example /\u0026gt; 7 \u0026lt;/QueryClientProvider\u0026gt; 8 ) 9} 10 11function Example() { 12 // 🚨 you cannot override this setting for tests! 13 const queryInfo = useQuery({ 14 queryKey: [\u0026#39;todos\u0026#39;], 15 queryFn: fetchTodos, 16 retry: 5, 17 }) 18} 改成这样：\n1const queryClient = new QueryClient({ 2 defaultOptions: { 3 queries: { 4 retry: 2, 5 }, 6 }, 7}) 8 9// ✅ only todos will retry 5 times 10queryClient.setQueryDefaults([\u0026#39;todos\u0026#39;], { retry: 5 }) 11 12function App() { 13 return ( 14 \u0026lt;QueryClientProvider client={queryClient}\u0026gt; 15 \u0026lt;Example /\u0026gt; 16 \u0026lt;/QueryClientProvider\u0026gt; 17 ) 18} 这样，所有的查询都会尝试两次，只有todos会重试五次，而且我也还有选项来在测试中把所有的查询都关掉🙌。\nReactQueryConfigProvider 当然，这仅适用于已知的查询键。有时，你确实需要在组件树的某个子集上设置一些配置。在v2中，React Query提供了ReactQueryConfigProvider来满足这个特定的用例。你可以在v3中使用几行代码实现相同的效果：\n1const ReactQueryConfigProvider = ({ children, defaultOptions }) =\u0026gt; { 2 const client = useQueryClient() 3 const [newClient] = React.useState( 4 () =\u0026gt; 5 new QueryClient({ 6 queryCache: client.getQueryCache(), 7 muationCache: client.getMutationCache(), 8 defaultOptions, 9 }) 10 ) 11 12 return ( 13 \u0026lt;QueryClientProvider client={newClient}\u0026gt;{children}\u0026lt;/QueryClientProvider\u0026gt; 14 ) 15} 你也可以在这个codesandbox的示例里看到。\n始终等待查询的完成 Since React Query is async by nature, when running the hook, you won't immediately get a result. It usually will be in loading state and without data to check. The async utilities from react-hooks-testing-library offer a lot of ways to solve this problem. For the simplest case, we can just wait until the query has transitioned to success state:\n由于React Query的本质是异步的，当运行hooks时，你并不会立即获得结果。它通常处于加载状态并且没有数据可供检查。react-hooks-testing-library的异步工具提供了许多解决此问题的方法。对于最简单的情况，我们可以等待查询过渡到成功状态：\n1const createWrapper = () =\u0026gt; { 2 const queryClient = new QueryClient({ 3 defaultOptions: { 4 queries: { 5 retry: false, 6 }, 7 }, 8 }) 9 return ({ children }) =\u0026gt; ( 10 \u0026lt;QueryClientProvider client={queryClient}\u0026gt;{children}\u0026lt;/QueryClientProvider\u0026gt; 11 ) 12} 13 14test(\u0026#34;my first test\u0026#34;, async () =\u0026gt; { 15 const { result, waitFor } = renderHook(() =\u0026gt; useCustomHook(), { 16 wrapper: createWrapper() 17 }) 18 19 // ✅ wait until the query has transitioned to success state 20 await waitFor(() =\u0026gt; result.current.isSuccess) 21 22 expect(result.current.data).toBeDefined() 23} 更新：\n@testing-library/react v13.1.0也有一个新的渲染hook。然而，它并不返回自己的waitFor，因此你需要从@testing-library/react导入。其API有些不同，它不允许返回布尔值，而是期望返回一个Promise。这意味着我们必须稍微调整我们的代码：\n1import { waitFor, renderHook } from \u0026#39;@testing-library/react\u0026#39; 2 3test(\u0026#34;my first test\u0026#34;, async () =\u0026gt; { 4 const { result } = renderHook(() =\u0026gt; useCustomHook(), { 5 wrapper: createWrapper() 6 }) 7 8 // ✅ return a Promise via expect to waitFor 9 await waitFor(() =\u0026gt; expect(result.current.isSuccess).toBe(true)) 10 11 expect(result.current.data).toBeDefined() 12} 静默错误控制台 默认情况下，React Query将错误打印到控制台。我认为这在测试过程中相当令人困扰，因为即使所有测试都是绿色的，你也会在控制台上看到🔴。React Query允许通过设置日志记录器来覆盖默认行为，这通常是我所做的：\n1import { setLogger } from \u0026#39;react-query\u0026#39; 2 3setLogger({ 4 log: console.log, 5 warn: console.warn, 6 // ✅ no more errors on the console 7 error: () =\u0026gt; {}, 8}) 更新：\nsetLogger已经从v4中移除了。取而代之的，你可以把你自定义的logger作为参数传递给你所创建的QueryClient:\n1const queryClient = new QueryClient({ 2 logger: { 3 log: console.log, 4 warn: console.warn, 5 // ✅ no more errors on the console 6 error: () =\u0026gt; {}, 7 } 8}) 此外，在生产模式下不再记录错误，以避免混淆。\n将它们整合在一起 我创建了一个快速的存储库，将所有这些内容完美地结合在一起：mock-service-worker、react-testing-library和上述的包装器。它包含四个测试 - 用于自定义hook和组件的失败和成功示例。请在此处查看：https://github.com/TkDodo/testing-react-query\n","link":"https://xfsnowind.github.io/zh-cn/blogs/react-query/testing-react-query/","section":"blogs","tags":["React Query","Translation","Blogs"],"title":"测试React Query"},{"body":"","link":"https://xfsnowind.github.io/zh-cn/tags/javascript/","section":"tags","tags":null,"title":"Javascript"},{"body":"","link":"https://xfsnowind.github.io/zh-cn/tags/learning-notes/","section":"tags","tags":null,"title":"Learning Notes"},{"body":"Basic chapter Reason to Hooks React的本质就是从Model到View的映射。这里的Model就是Component的props和state。\n当Model的数据变化时，React不管它是怎么变化的，只关心它变化之后和之前的区别。这也就是所谓的声明式declarative，而这通过React的diff函数来实现。\n所以UI的展现更像是一个函数的执行。Model是输入参数，View是函数，执行结果就是Dom的改变。而React只要保证通过最优的办法执行变化的过程就行了。\nClass作为React Component不合适的两点:\nReact Component之间很少使用继承. React是由state驱动的，并不需要调用外部生成的class的instance的method。 Function作为React Component的局限:\nFunction无法提供内部状态，必须是纯函数 Function也无法提供完整的lifecycle 所以React的中的Hooks就是把target钩到某个可能会变化的data source或者event source中，当被钩到的data或者event变化的时候，这个target会被重新执行，产生新的结果。\nHooks中被钩的对象不仅仅可以是数据，也可以是另一个Hook执行的结果，这样可以带来逻辑的复用。\nHooks是在High order Component的使用背景下被创造出来的，所以Hook解决了HOC留下的wrapper hell和code难以理解的问题\nHooks basic usage useState -- 使用useState保存的值的原则是，不要使用需要计算得到的值 useEffect -- 应该用来执行并不影响当前结果的代码，是不影响当前渲染出来的UI的 Deps使用reference来比较值是否有变化，所以数组和object要小心 NB: useEffect是在render执行之后调用的 useCallback -- 这个hook的使用目的是，在需要把函数作为值来传递到UI的时候，为了避免多余的render，而保证在某些条件传递的函数本身是不变的 useMemo -- useMemo其实可以理解为useEffect和useState的结合，即在deps变化的时候来执行useEffect的函数来计算值的变化，同时将值通过useState来赋予state useRef 在多次渲染之间共享数据 存某个 DOM 节点的引用 useContext -- 定义全局状态 useEffect基本上等价于componentDidMount, componentDidUpdate 和componentWillUnmount。但是并不完全等价。区别在于： useEffect的callback函数只有在deps变化的时候才会被调用，而componentDidUpdate则一定会被调用 useEffect里callback函数的返回函数(用来做清理工作)，是在依赖项变化或者组件销毁前被调用\n如果需要有一个constructor的功能，可以使用以下代码：\n1// 创建一个自定义 Hook 用于执行一次性代码 2function useSingleton(callback) { 3 // 用一个 called ref 标记 callback 是否执行过 4 const called = useRef(false); 5 // 如果已经执行过，则直接返回 6 if (called.current) return; 7 // 第一次调用时直接执行 8 callBack(); 9 // 设置标记为已执行过 10 called.current = true; 11} Hook可以实现大部分的lifecycle的功能，但是对于 getSnapshotBeforeUpdate, componentDidCatch, getDerivedStateFromError，这些周期还是只能使用class来实现\nPractice Data consistence 在保证 State 完整性的同时，也要保证它的最小化。 某些数据如果能从已有的 State 中计算得到，那么我们就应该始终在用的时候去计算，而不要把计算的结果存到某个 State 中。\n避免中间状态，确保唯一数据源 在任何时候想要定义新状态的时候，都要问自己一下：这个状态有必要吗？是否能通过计算得到？是否只是一个中间状态？\nRender props模式 通过把render函数传递给某个组件，让这个render函数来决定渲染的效果，从而实现组件的复用\nSelf defined event Synthetic Event 当我们绑定一个时间到节点上的时候，因为virtual dom的存在，react会把时间绑定到APP根节点上，React 17之前是在document上，17以后是在react的根节点上 一是因为virtual dom在render的时候，可能节点还没有render到页面上，所以无法绑定 二是可以屏蔽底层细节，避免浏览器兼容性问题\n所以react component自定义的事件本质上是回调函数\nOrganize project structure via business 为了降低项目的复杂度，通过业务特征和逻辑来组织项目结构，这样可以让各个feature能相对独立，便于管理和维护\n为了实现松耦合，可以针对dynamic的部分单独设计组件，并传递动态的参数以达到动态内容的修改不影响其他部分\nForm React是状态驱动，Form是事件驱动 React的onChange函数会在用户任何输入的时候都调用函数，但是html的原生onchange函数则只会在输入框失去focus的时候触发\nControlled vs uncontrolled 对于uncontrolled component，并不会传递value给component，而是通过获取这个component的值来得到其状态，例如useRef。好处在于，其值的变化并不会触发render。坏处则是无法检测值的变化\n而对于controlled component，则接受value as props，同时一个callback函数来update这个值\nForm elements 使用Controlled component来维护表单主要核心三个部分：\n字段的名称 绑定value 处理onChange事件 所以Hook对于Form的贡献在于，可以把Form里面的value都放到hook里面，并且通过useState来提供处理的函数。例如：\n1import { useState, useCallback } from \u0026#34;react\u0026#34;; 2 3const useForm = (initialValues = {}) =\u0026gt; { 4 // 设置整个 form 的状态：values 5 const [values, setValues] = useState(initialValues); 6 7 // 提供一个方法用于设置 form 上的某个字段的值 8 const setFieldValue = useCallback((name, value) =\u0026gt; { 9 setValues((values) =\u0026gt; ({ 10 ...values, 11 [name]: value, 12 })); 13 }, []); 14 15 // 返回整个 form 的值以及设置值的方法 16 return { values, setFieldValue }; 17}; ","link":"https://xfsnowind.github.io/zh-cn/blogs/geektime/react-hooks/","section":"blogs","tags":["Javascript","React Hooks","Learning Notes"],"title":"Learning Notes - React Hooks"},{"body":"","link":"https://xfsnowind.github.io/zh-cn/tags/react-hooks/","section":"tags","tags":null,"title":"React Hooks"},{"body":"","link":"https://xfsnowind.github.io/zh-cn/categories/","section":"categories","tags":null,"title":"Categories"},{"body":"","link":"https://xfsnowind.github.io/zh-cn/series/","section":"series","tags":null,"title":"Series"}]