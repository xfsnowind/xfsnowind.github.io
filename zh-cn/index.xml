<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>xfsnowind</title><link>https://xfsnowind.github.io/zh-cn/</link><description>Recent content on xfsnowind</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sat, 17 Jun 2023 18:08:37 +0800</lastBuildDate><atom:link href="https://xfsnowind.github.io/zh-cn/index.xml" rel="self" type="application/rss+xml"/><item><title>React Query Effective Query Keys</title><link>https://xfsnowind.github.io/zh-cn/blogs/react-query/react-query-effective-query-keys/</link><pubDate>Sat, 17 Jun 2023 16:02:03 +0800</pubDate><guid>https://xfsnowind.github.io/zh-cn/blogs/react-query/react-query-effective-query-keys/</guid><description>
Query Keys是React Query中非常重要的核心概念。它们可以使库能够正确地内部缓存数据，并在查询的依赖发生更改时自动重新获取数据。最后，它将允许你在需要时手动与查询缓存进行交互，例如在执行变更后更新数据或手动使某些查询失效。
在向你展示我个人如何组织Query Keys以更有效地执行这些操作之前，让我们快速了解一下这三个要点的含义。
缓存数据 在内部，查询缓存只是一个JavaScript对象，其中键是序列化的Query Keys，值是你的查询数据加上元信息。键以deterministic way进行散列，因此你也可以使用对象（但在顶层，键必须是字符串或数组）。
最重要的部分是，键对于你的查询必须是唯一的。如果React Query在缓存中找到一个键的条目，它就会用它。还请注意，你不能将相同的键用于 useQuery 和 useInfiniteQuery。毕竟，只有一个查询缓存，数据会在这两者之间共享。这会造成问题，因为无限查询与常规查询具有根本不同的结构。
1useQuery({ queryKey: [&amp;#39;todos&amp;#39;], queryFn: fetchTodos }) 2 3// 🚨 这不可行 4useInfiniteQuery({ queryKey: [&amp;#39;todos&amp;#39;], queryFn: fetchInfiniteTodos }) 5 6// ✅ 选择其他内容 7useInfiniteQuery({ 8 queryKey: [&amp;#39;infiniteTodos&amp;#39;], 9 queryFn: fetchInfiniteTodos, 10}) 自动重新获取 查询是声明性的。
这是一个非常重要的概念，怎么强调都不过分，而且这也是可能需要一些时间来理解的概念。大多数人以命令式的方式思考查询，尤其是重新获取。
我有一个查询，它获取一些数据。现在我点击这个按钮，我想要重新获取，但使用不同的参数。我看到过许多类似下面这样的尝试：
1function Component() { 2 const { data, refetch } = useQuery({ 3 queryKey: [&amp;#39;todos&amp;#39;], 4 queryFn: fetchTodos, 5 }) 6 7 // ❓ 如何将参数传递给 refetch ❓ 8 return &amp;lt;Filters onApply={() =&amp;gt; refetch(?</description></item><item><title>使用React Query和Web Sockets</title><link>https://xfsnowind.github.io/zh-cn/blogs/react-query/using-web-sockets-with-react-query/</link><pubDate>Sat, 17 Jun 2023 14:48:58 +0800</pubDate><guid>https://xfsnowind.github.io/zh-cn/blogs/react-query/using-web-sockets-with-react-query/</guid><description>
本文翻译自 TkDodo 的 Using WebSockets with React Query
如何使用WebSockets与React Query处理实时数据是最近最常被问到的问题之一，因此我想尝试一下，并报告我的发现。这就是本文的内容 :)
什么是WebSockets 简而言之，WebSockets允许从服务器推送消息或&amp;quot;实时数据&amp;quot;到客户端（浏览器）。通常情况下，使用HTTP时，客户端向服务器发出请求，希望获取一些数据，服务器响应该数据或错误，然后连接关闭。
由于客户端是打开连接并发起请求的一方，这就没有机会让服务器在有更新可用时向客户端推送数据。
这就是WebSockets的作用。
就像其他HTTP请求一样，浏览器发起连接，但表示希望将连接升级为WebSocket。如果服务器接受了这个请求，它们将切换协议。这个连接不会终止，而是保持打开状态，直到任一方决定关闭它。现在，我们拥有了一个完全功能的双向连接，双方都可以传输数据。
这主要的优点是服务器现在可以向客户端推送选择性的更新。如果多个用户查看相同的数据，并且其中一个用户进行了更新。通常情况下，其他客户端在主动刷新之前不会看到该更新。而使用WebSockets可以实时推送这些更新。
React Query 集成 由于React Query主要是一个客户端异步状态管理库，所以我不会讨论如何在服务器上设置WebSockets。老实说，我从没做过，而且还取决于你在后端使用的技术。
React Query没有专门为WebSockets构建的内置功能。这并不意味着不支持WebSockets，或者它们与库的兼容性不好。只是当涉及到数据获取时，React Query在使用方式上非常不偏不倚：它只需要一个已解决或拒绝的Promise即可工作 - 其余的由你决定。
逐步进行 一般的思路是按照通常的方式设置查询，就像你不使用WebSockets一样。大多数情况下，你将拥有用于查询和更改实体的常规HTTP端点。
1const usePosts = () =&amp;gt; 2 useQuery({ queryKey: [&amp;#39;posts&amp;#39;, &amp;#39;list&amp;#39;], queryFn: fetchPosts }) 3 4const usePost = (id) =&amp;gt; 5 useQuery({ 6 queryKey: [&amp;#39;posts&amp;#39;, &amp;#39;detail&amp;#39;, id], 7 queryFn: () =&amp;gt; fetchPost(id), 8 }) 此外，你可以设置一个全局的useEffect来连接到WebSocket终端。具体如何操作完全取决于你使用的技术。我看到过有人从Hasura订阅实时数据。有一篇很棒的文章介绍了如何连接到Firebase。在我的示例中，我将简单地使用浏览器原生的WebSocket API：
1const useReactQuerySubscription = () =&amp;gt; { 2 React.</description></item><item><title>测试React Query</title><link>https://xfsnowind.github.io/zh-cn/blogs/react-query/testing-react-query/</link><pubDate>Mon, 12 Jun 2023 23:56:57 +0800</pubDate><guid>https://xfsnowind.github.io/zh-cn/blogs/react-query/testing-react-query/</guid><description>
本文翻译自 TkDodo 的 Testing React Query
谈到测试，经常会和React Query一起出现一些问题，所以我将在这里尝试回答其中的一些问题。我认为其中一个原因是测试“智能”组件（也称为容器组件）并不是一件容易的事情。随着hooks的兴起，这种分离已经大部分过时。现在倾向于直接在需要它们的地方使用hooks，而不是进行主要是随意地分离并向下传递props。
我认为这通常是一个非常好的改进，有助于集中放置和代码可读性，但现在更多组件会去消耗props之外的依赖项。
它们可能是useContext。它们可能是useSelector。或者它们可能是useQuery。
这些组件在技术上不再是纯净的，因为在不同的环境中调用它们会导致不同的结果。在测试它们时，你需要仔细设置这些周围的环境以使其正常工作。
模拟网络请求 由于React Query是一个异步的服务器状态管理库，你的组件很可能会向后端发送请求。在测试时，这个后端无法用以提供真实数据，即使可用，你可能也不希望使测试依赖于它。
已经有海量的文章介绍如何使用jest模拟数据。如果你有api客户端，可以模拟它。你可以直接模拟fetch或axios。我非常认同Kent C. Dodds在他的文章《Stop mocking fetch》中所写的内容：
使用@ApiMocking的mock service worker
在模拟API方面，它可以成为你的唯一真实来源：
适用于测试的Node环境 支持REST和GraphQL 具有storybook插件，因此你可以为使用useQuery的组件编写story 在浏览器中用于开发目的，你仍然可以在浏览器开发工具中看到请求的发送情况 与Cypress一起使用，类似于fixtures 通过处理我们的网络层，我们可以开始讨论一些需要关注的React Query特定事项：
QueryClientProvider 每当你使用React Query时，你需要一个QueryClientProvider，并给它一个queryClient——这是一个保存QueryCache的容器。而Cache会保存你的请求的数据。
我更喜欢为每个测试提供独立的QueryClientProvider，并为每个测试创建一个新的QueryClient。这样，测试之间完全隔离。另一种方法可能是在每个测试之后清除缓存，但我喜欢尽量将测试之间的共享状态保持最小化。否则，如果你同时运行测试，可能会出现意外和不稳定的结果。
对于自定义的Hooks 如果你正在测试自定义hooks，我非常确定你正在使用react-hooks-testing-library。这是最简单的测试hooks的方法。我们可以通过这个库将我们的钩子包装在一个包装器中，该包装器是一个React组件，在渲染时用于包装测试组件。我认为这是创建QueryClient的理想位置，因为它将在每个测试中都执行一次：
1const createWrapper = () =&amp;gt; { 2 // ✅ creates a new QueryClient for each test 3 const queryClient = new QueryClient() 4 return ({ children }) =&amp;gt; ( 5 &amp;lt;QueryClientProvider client={queryClient}&amp;gt;{children}&amp;lt;/QueryClientProvider&amp;gt; 6 ) 7} 8 9test(&amp;#34;my first test&amp;#34;, async () =&amp;gt; { 10 const { result } = renderHook(() =&amp;gt; useCustomHook(), { 11 wrapper: createWrapper() 12 }) 13}) 对于组件 如果你想测试一个使用useQuery hooks的组件，你还需要将该组件包在QueryClientProvider中。使用react-testing-library里的一个小包装器包住render似乎是一个不错的选择。看看React Query在他们的测试中是如何内部处理的。</description></item><item><title>Learning Notes - React Hooks</title><link>https://xfsnowind.github.io/zh-cn/blogs/geektime/react-hooks/</link><pubDate>Tue, 09 Aug 2022 20:27:47 +0200</pubDate><guid>https://xfsnowind.github.io/zh-cn/blogs/geektime/react-hooks/</guid><description>
Basic chapter Reason to Hooks React的本质就是从Model到View的映射。这里的Model就是Component的props和state。
当Model的数据变化时，React不管它是怎么变化的，只关心它变化之后和之前的区别。这也就是所谓的声明式declarative，而这通过React的diff函数来实现。
所以UI的展现更像是一个函数的执行。Model是输入参数，View是函数，执行结果就是Dom的改变。而React只要保证通过最优的办法执行变化的过程就行了。
Class作为React Component不合适的两点:
React Component之间很少使用继承. React是由state驱动的，并不需要调用外部生成的class的instance的method。 Function作为React Component的局限:
Function无法提供内部状态，必须是纯函数 Function也无法提供完整的lifecycle 所以React的中的Hooks就是把target钩到某个可能会变化的data source或者event source中，当被钩到的data或者event变化的时候，这个target会被重新执行，产生新的结果。
Hooks中被钩的对象不仅仅可以是数据，也可以是另一个Hook执行的结果，这样可以带来逻辑的复用。
Hooks是在High order Component的使用背景下被创造出来的，所以Hook解决了HOC留下的wrapper hell和code难以理解的问题
Hooks basic usage useState -- 使用useState保存的值的原则是，不要使用需要计算得到的值 useEffect -- 应该用来执行并不影响当前结果的代码，是不影响当前渲染出来的UI的 Deps使用reference来比较值是否有变化，所以数组和object要小心 NB: useEffect是在render执行之后调用的 useCallback -- 这个hook的使用目的是，在需要把函数作为值来传递到UI的时候，为了避免多余的render，而保证在某些条件传递的函数本身是不变的 useMemo -- useMemo其实可以理解为useEffect和useState的结合，即在deps变化的时候来执行useEffect的函数来计算值的变化，同时将值通过useState来赋予state useRef 在多次渲染之间共享数据 存某个 DOM 节点的引用 useContext -- 定义全局状态 useEffect基本上等价于componentDidMount, componentDidUpdate 和componentWillUnmount。但是并不完全等价。区别在于： useEffect的callback函数只有在deps变化的时候才会被调用，而componentDidUpdate则一定会被调用 useEffect里callback函数的返回函数(用来做清理工作)，是在依赖项变化或者组件销毁前被调用
如果需要有一个constructor的功能，可以使用以下代码：
1// 创建一个自定义 Hook 用于执行一次性代码 2function useSingleton(callback) { 3 // 用一个 called ref 标记 callback 是否执行过 4 const called = useRef(false); 5 // 如果已经执行过，则直接返回 6 if (called.</description></item></channel></rss>