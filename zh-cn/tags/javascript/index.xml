<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Javascript on xfsnowind</title><link>https://xfsnowind.github.io/zh-cn/tags/javascript/</link><description>Recent content in Javascript on xfsnowind</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 09 Aug 2022 20:27:47 +0200</lastBuildDate><atom:link href="https://xfsnowind.github.io/zh-cn/tags/javascript/index.xml" rel="self" type="application/rss+xml"/><item><title>Learning Notes - React Hooks</title><link>https://xfsnowind.github.io/zh-cn/blogs/geektime/react-hooks/</link><pubDate>Tue, 09 Aug 2022 20:27:47 +0200</pubDate><guid>https://xfsnowind.github.io/zh-cn/blogs/geektime/react-hooks/</guid><description>
Basic chapter Reason to Hooks React的本质就是从Model到View的映射。这里的Model就是Component的props和state。
当Model的数据变化时，React不管它是怎么变化的，只关心它变化之后和之前的区别。这也就是所谓的声明式declarative，而这通过React的diff函数来实现。
所以UI的展现更像是一个函数的执行。Model是输入参数，View是函数，执行结果就是Dom的改变。而React只要保证通过最优的办法执行变化的过程就行了。
Class作为React Component不合适的两点:
React Component之间很少使用继承. React是由state驱动的，并不需要调用外部生成的class的instance的method。 Function作为React Component的局限:
Function无法提供内部状态，必须是纯函数 Function也无法提供完整的lifecycle 所以React的中的Hooks就是把target钩到某个可能会变化的data source或者event source中，当被钩到的data或者event变化的时候，这个target会被重新执行，产生新的结果。
Hooks中被钩的对象不仅仅可以是数据，也可以是另一个Hook执行的结果，这样可以带来逻辑的复用。
Hooks是在High order Component的使用背景下被创造出来的，所以Hook解决了HOC留下的wrapper hell和code难以理解的问题
Hooks basic usage useState -- 使用useState保存的值的原则是，不要使用需要计算得到的值 useEffect -- 应该用来执行并不影响当前结果的代码，是不影响当前渲染出来的UI的 Deps使用reference来比较值是否有变化，所以数组和object要小心 NB: useEffect是在render执行之后调用的 useCallback -- 这个hook的使用目的是，在需要把函数作为值来传递到UI的时候，为了避免多余的render，而保证在某些条件传递的函数本身是不变的 useMemo -- useMemo其实可以理解为useEffect和useState的结合，即在deps变化的时候来执行useEffect的函数来计算值的变化，同时将值通过useState来赋予state useRef 在多次渲染之间共享数据 存某个 DOM 节点的引用 useContext -- 定义全局状态 useEffect基本上等价于componentDidMount, componentDidUpdate 和componentWillUnmount。但是并不完全等价。区别在于： useEffect的callback函数只有在deps变化的时候才会被调用，而componentDidUpdate则一定会被调用 useEffect里callback函数的返回函数(用来做清理工作)，是在依赖项变化或者组件销毁前被调用
如果需要有一个constructor的功能，可以使用以下代码：
1// 创建一个自定义 Hook 用于执行一次性代码 2function useSingleton(callback) { 3 // 用一个 called ref 标记 callback 是否执行过 4 const called = useRef(false); 5 // 如果已经执行过，则直接返回 6 if (called.</description></item></channel></rss>