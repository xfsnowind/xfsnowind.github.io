<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Typescript on xfsnowind</title><link>https://xfsnowind.github.io/zh-cn/tags/typescript/</link><description>Recent content in Typescript on xfsnowind</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sat, 17 Jun 2023 16:02:03 +0800</lastBuildDate><atom:link href="https://xfsnowind.github.io/zh-cn/tags/typescript/index.xml" rel="self" type="application/rss+xml"/><item><title>React Query Effective Query Keys</title><link>https://xfsnowind.github.io/zh-cn/blogs/react-query/react-query-effective-query-keys/</link><pubDate>Sat, 17 Jun 2023 16:02:03 +0800</pubDate><guid>https://xfsnowind.github.io/zh-cn/blogs/react-query/react-query-effective-query-keys/</guid><description>
Query Keys是React Query中非常重要的核心概念。它们可以使库能够正确地内部缓存数据，并在查询的依赖发生更改时自动重新获取数据。最后，它将允许你在需要时手动与查询缓存进行交互，例如在执行变更后更新数据或手动使某些查询失效。
在向你展示我个人如何组织Query Keys以更有效地执行这些操作之前，让我们快速了解一下这三个要点的含义。
缓存数据 在内部，查询缓存只是一个JavaScript对象，其中键是序列化的Query Keys，值是你的查询数据加上元信息。键以deterministic way进行散列，因此你也可以使用对象（但在顶层，键必须是字符串或数组）。
最重要的部分是，键对于你的查询必须是唯一的。如果React Query在缓存中找到一个键的条目，它就会用它。还请注意，你不能将相同的键用于 useQuery 和 useInfiniteQuery。毕竟，只有一个查询缓存，数据会在这两者之间共享。这会造成问题，因为无限查询与常规查询具有根本不同的结构。
1useQuery({ queryKey: [&amp;#39;todos&amp;#39;], queryFn: fetchTodos }) 2 3// 🚨 这不可行 4useInfiniteQuery({ queryKey: [&amp;#39;todos&amp;#39;], queryFn: fetchInfiniteTodos }) 5 6// ✅ 选择其他内容 7useInfiniteQuery({ 8 queryKey: [&amp;#39;infiniteTodos&amp;#39;], 9 queryFn: fetchInfiniteTodos, 10}) 自动重新获取 查询是声明性的。
这是一个非常重要的概念，怎么强调都不过分，而且这也是可能需要一些时间来理解的概念。大多数人以命令式的方式思考查询，尤其是重新获取。
我有一个查询，它获取一些数据。现在我点击这个按钮，我想要重新获取，但使用不同的参数。我看到过许多类似下面这样的尝试：
1function Component() { 2 const { data, refetch } = useQuery({ 3 queryKey: [&amp;#39;todos&amp;#39;], 4 queryFn: fetchTodos, 5 }) 6 7 // ❓ 如何将参数传递给 refetch ❓ 8 return &amp;lt;Filters onApply={() =&amp;gt; refetch(?</description></item><item><title>使用React Query和Web Sockets</title><link>https://xfsnowind.github.io/zh-cn/blogs/react-query/using-web-sockets-with-react-query/</link><pubDate>Sat, 17 Jun 2023 14:48:58 +0800</pubDate><guid>https://xfsnowind.github.io/zh-cn/blogs/react-query/using-web-sockets-with-react-query/</guid><description>
本文翻译自 TkDodo 的 Using WebSockets with React Query
如何使用WebSockets与React Query处理实时数据是最近最常被问到的问题之一，因此我想尝试一下，并报告我的发现。这就是本文的内容 :)
什么是WebSockets 简而言之，WebSockets允许从服务器推送消息或&amp;quot;实时数据&amp;quot;到客户端（浏览器）。通常情况下，使用HTTP时，客户端向服务器发出请求，希望获取一些数据，服务器响应该数据或错误，然后连接关闭。
由于客户端是打开连接并发起请求的一方，这就没有机会让服务器在有更新可用时向客户端推送数据。
这就是WebSockets的作用。
就像其他HTTP请求一样，浏览器发起连接，但表示希望将连接升级为WebSocket。如果服务器接受了这个请求，它们将切换协议。这个连接不会终止，而是保持打开状态，直到任一方决定关闭它。现在，我们拥有了一个完全功能的双向连接，双方都可以传输数据。
这主要的优点是服务器现在可以向客户端推送选择性的更新。如果多个用户查看相同的数据，并且其中一个用户进行了更新。通常情况下，其他客户端在主动刷新之前不会看到该更新。而使用WebSockets可以实时推送这些更新。
React Query 集成 由于React Query主要是一个客户端异步状态管理库，所以我不会讨论如何在服务器上设置WebSockets。老实说，我从没做过，而且还取决于你在后端使用的技术。
React Query没有专门为WebSockets构建的内置功能。这并不意味着不支持WebSockets，或者它们与库的兼容性不好。只是当涉及到数据获取时，React Query在使用方式上非常不偏不倚：它只需要一个已解决或拒绝的Promise即可工作 - 其余的由你决定。
逐步进行 一般的思路是按照通常的方式设置查询，就像你不使用WebSockets一样。大多数情况下，你将拥有用于查询和更改实体的常规HTTP端点。
1const usePosts = () =&amp;gt; 2 useQuery({ queryKey: [&amp;#39;posts&amp;#39;, &amp;#39;list&amp;#39;], queryFn: fetchPosts }) 3 4const usePost = (id) =&amp;gt; 5 useQuery({ 6 queryKey: [&amp;#39;posts&amp;#39;, &amp;#39;detail&amp;#39;, id], 7 queryFn: () =&amp;gt; fetchPost(id), 8 }) 此外，你可以设置一个全局的useEffect来连接到WebSocket终端。具体如何操作完全取决于你使用的技术。我看到过有人从Hasura订阅实时数据。有一篇很棒的文章介绍了如何连接到Firebase。在我的示例中，我将简单地使用浏览器原生的WebSocket API：
1const useReactQuerySubscription = () =&amp;gt; { 2 React.</description></item><item><title>测试React Query</title><link>https://xfsnowind.github.io/zh-cn/blogs/react-query/testing-react-query/</link><pubDate>Mon, 12 Jun 2023 23:56:57 +0800</pubDate><guid>https://xfsnowind.github.io/zh-cn/blogs/react-query/testing-react-query/</guid><description>
本文翻译自 TkDodo 的 Testing React Query
谈到测试，经常会和React Query一起出现一些问题，所以我将在这里尝试回答其中的一些问题。我认为其中一个原因是测试“智能”组件（也称为容器组件）并不是一件容易的事情。随着hooks的兴起，这种分离已经大部分过时。现在倾向于直接在需要它们的地方使用hooks，而不是进行主要是随意地分离并向下传递props。
我认为这通常是一个非常好的改进，有助于集中放置和代码可读性，但现在更多组件会去消耗props之外的依赖项。
它们可能是useContext。它们可能是useSelector。或者它们可能是useQuery。
这些组件在技术上不再是纯净的，因为在不同的环境中调用它们会导致不同的结果。在测试它们时，你需要仔细设置这些周围的环境以使其正常工作。
模拟网络请求 由于React Query是一个异步的服务器状态管理库，你的组件很可能会向后端发送请求。在测试时，这个后端无法用以提供真实数据，即使可用，你可能也不希望使测试依赖于它。
已经有海量的文章介绍如何使用jest模拟数据。如果你有api客户端，可以模拟它。你可以直接模拟fetch或axios。我非常认同Kent C. Dodds在他的文章《Stop mocking fetch》中所写的内容：
使用@ApiMocking的mock service worker
在模拟API方面，它可以成为你的唯一真实来源：
适用于测试的Node环境 支持REST和GraphQL 具有storybook插件，因此你可以为使用useQuery的组件编写story 在浏览器中用于开发目的，你仍然可以在浏览器开发工具中看到请求的发送情况 与Cypress一起使用，类似于fixtures 通过处理我们的网络层，我们可以开始讨论一些需要关注的React Query特定事项：
QueryClientProvider 每当你使用React Query时，你需要一个QueryClientProvider，并给它一个queryClient——这是一个保存QueryCache的容器。而Cache会保存你的请求的数据。
我更喜欢为每个测试提供独立的QueryClientProvider，并为每个测试创建一个新的QueryClient。这样，测试之间完全隔离。另一种方法可能是在每个测试之后清除缓存，但我喜欢尽量将测试之间的共享状态保持最小化。否则，如果你同时运行测试，可能会出现意外和不稳定的结果。
对于自定义的Hooks 如果你正在测试自定义hooks，我非常确定你正在使用react-hooks-testing-library。这是最简单的测试hooks的方法。我们可以通过这个库将我们的钩子包装在一个包装器中，该包装器是一个React组件，在渲染时用于包装测试组件。我认为这是创建QueryClient的理想位置，因为它将在每个测试中都执行一次：
1const createWrapper = () =&amp;gt; { 2 // ✅ creates a new QueryClient for each test 3 const queryClient = new QueryClient() 4 return ({ children }) =&amp;gt; ( 5 &amp;lt;QueryClientProvider client={queryClient}&amp;gt;{children}&amp;lt;/QueryClientProvider&amp;gt; 6 ) 7} 8 9test(&amp;#34;my first test&amp;#34;, async () =&amp;gt; { 10 const { result } = renderHook(() =&amp;gt; useCustomHook(), { 11 wrapper: createWrapper() 12 }) 13}) 对于组件 如果你想测试一个使用useQuery hooks的组件，你还需要将该组件包在QueryClientProvider中。使用react-testing-library里的一个小包装器包住render似乎是一个不错的选择。看看React Query在他们的测试中是如何内部处理的。</description></item></channel></rss>